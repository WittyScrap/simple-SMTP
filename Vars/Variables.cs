using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Collections;
using System.Text.RegularExpressions;

namespace VariableManagement
{
	/// <summary>
	/// Represents a .vars file parsed as an object.
	/// </summary>
	public class Variables : IReadOnlyDictionary<string, object>
	{
		/// <summary>
		/// Initialises the root object.
		/// </summary>
		public Variables()
		{
			Root = new VariablesObject();
		}

		/// <summary>
		/// Accesses a variable through a key.
		/// </summary>
		public object this[string key] {
			get
			{
				Queue<string> components = new Queue<string>(key.Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries));
				VariablesObject previous = Root;

				while (components.Count > 1)
				{
					string nextkey = components.Dequeue();
					previous = previous.GetObject(nextkey);

					if (previous == null)
					{
						throw new Exception("Key " + nextkey + " does not exist in object " + this + "!");
					}
				}

				return previous.GetField(components.Dequeue());
			}
			set
			{
				Queue<string> components = new Queue<string>(key.Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries));
				VariablesObject previous = Root;

				while (components.Count > 1)
				{
					string nextkey = components.Dequeue();
					previous = previous.GetObject(nextkey);

					if (previous == null)
					{
						throw new Exception("Key " + nextkey + " does not exist in object " + this + "!");
					}
				}

				previous.SetFieldValue(components.Dequeue(), value);
			}
		}

		/// <summary>
		/// Loads a vars object from a file.
		/// </summary>
		public static Variables Load(string fileName)
		{
			if (!File.Exists(fileName))
			{
				throw new Exception("Unable to open file: " + fileName);
			}

			Variables varsObject = new Variables();

			string fileData = File.ReadAllText(fileName);

			string[] strings = SplitAround(fileData, new char[] { '"' }, false).ToArray();
			string[] tokens = varsObject.GetTokens(strings);

			varsObject.Parse(tokens);

			return varsObject;
		}

		/// <summary>
		/// Retrieves tokens from string-parsed input.
		/// </summary>
		private string[] GetTokens(string[] strings)
		{
			// Even number of elements means a string has remained open
			if (strings.Length % 2 == 0)
			{
				throw new ParserException("A previously opened string has not been closed.");
			}

			List<string> tokens = new List<string>();

			for (int i = 0; i < strings.Length; ++i)
			{
				if (i % 2 == 1)
				{
					tokens.Add(strings[i]);
				}
				else
				{
					string[] rawTokens = strings[i].Split(new char[] { ' ', '\n', '\t', '\r' }, StringSplitOptions.RemoveEmptyEntries);
					string[] cleanTokens = SplitAroundAll(rawTokens, '{', '}', ':', ';').ToArray();

					tokens.AddRange(cleanTokens);
				}
			}

			return tokens.ToArray();
		}

		/// <summary>
		/// Splits all strings in the array by the tokens and returns all substrings generated by it.
		/// </summary>
		private IEnumerable<string> SplitAroundAll(string[] values, params char[] tokens)
		{
			foreach (string value in values)
			{
				foreach (string element in SplitAround(value, tokens))
				{
					yield return element;
				}
			}
		}

		/// <summary>
		/// Checks that a key exists either as a field or object.
		/// </summary>
		/// <param name="key">The key to check for.</param>
		/// <returns>True if the key exists, false otherwise</returns>
		public bool ContainsKey(string key)
		{
			return Root.GetObject(key) != null || Root.GetField(key) != null;
		}

		/// <summary>
		/// No way to iterate through the object for now.
		/// </summary>
		/// <returns>null</returns>
		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			return null;
		}

		/// <summary>
		/// Attempts to extract an object first, then a key.
		/// If neither exists, false will be returned.
		/// </summary>
		/// <param name="key">The object/field to search for.</param>
		/// <param name="value">The value that will be retrieved.</param>
		/// <returns>True on succesful retrieval, false on faliure.</returns>
		public bool TryGetValue(string key, out object value)
		{
			value = Root.GetObject(key);
			if (value == null)
			{
				value = Root.GetField(key);
			}
			return value != null;
		}

		/// <summary>
		/// No way to iterate through the object for now.
		/// </summary>
		/// <returns>null</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return null;
		}

		/// <summary>
		/// Populates this class through deserialisation of parsed tokens.
		/// </summary>
		/// <param name="tokens">The tokens to populate the class from.</param>
		private void Parse(string[] tokens)
		{
			VariablesParser parser = new VariablesParser();
			parser.Parse(this, tokens);
		}

		/// <summary>
		/// Splits the string around the given tokens, for instance, with tokens:<br/>
		/// :,{}()<br/>
		/// And a string:<br/>
		/// alpha:bravo(c,d){example}<br/>
		/// An array containing values:<br/>
		/// [alpha][:][bravo][(][c][,][d][)][{][example][}]<br/>
		/// Should be generated.
		/// </summary>
		/// <param name="value">The source string.</param>
		/// <param name="tokens">The tokens to split the source string around.</param>
		public static IEnumerable<string> SplitAround(string value, char[] tokens, bool keepTokens = true)
		{
			if (tokens.Length == 0)
			{
				yield return value;
			}
			else
			{
				char delimiter = tokens[0];

				if (value.Length == 1 && value[0] == delimiter)
				{
					yield return value;
				}
				else
				{
					string[] segments = value.Split(delimiter);
					tokens = tokens.Skip(1).ToArray();

					for (int i = 0; i < segments.Length; ++i)
					{
						if (segments[i].Length > 0)
						{
							foreach (string subsegment in SplitAround(segments[i], tokens, keepTokens))
							{
								yield return subsegment;
							}
						}

						if (i < segments.Length - 1 && keepTokens)
						{
							yield return delimiter.ToString();
						}
					}
				}
			}
		}

		/* ------------ */
		/* --- Data --- */
		/* ------------ */

		// Root of the variables tree
		public VariablesObject Root { get; }

		/// <summary>
		/// No way to iteratively retrieve keys for now.
		/// </summary>
		public IEnumerable<string> Keys => null;

		/// <summary>
		/// No way to iteratively retrieve values for now.
		/// </summary>
		public IEnumerable<object> Values => null;

		/// <summary>
		/// No way to obtain the total amount of fields/objects for now.
		/// </summary>
		public int Count => -1;
	}
}
